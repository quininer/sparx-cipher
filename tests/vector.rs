extern crate sparx_cipher;

use sparx_cipher::Sparx;


#[test]
fn test_vector() {
    #[cfg(feature = "x64_128")] let key = [0x11, 0x00, 0x33, 0x22, 0x55, 0x44, 0x77, 0x66, 0x99, 0x88, 0xbb, 0xaa, 0xdd, 0xcc, 0xff, 0xee];
    #[cfg(feature = "x64_128")] let plaintext = [0x23, 0x01, 0x67, 0x45, 0xab, 0x89, 0xef, 0xcd];
    #[cfg(feature = "x64_128")] let ciphertext = [0xbe, 0x2b, 0x52, 0xf1, 0xf5, 0x01, 0x98, 0x5f];

    #[cfg(feature = "x128_128")] let key = [0x11, 0x00, 0x33, 0x22, 0x55, 0x44, 0x77, 0x66, 0x99, 0x88, 0xbb, 0xaa, 0xdd, 0xcc, 0xff, 0xee];
    #[cfg(feature = "x128_128")] let plaintext = [0x23, 0x01, 0x67, 0x45, 0xab, 0x89, 0xef, 0xcd, 0xdc, 0xfe, 0x98, 0xba, 0x54, 0x76, 0x10, 0x32];
    #[cfg(feature = "x128_128")] let ciphertext = [0xee, 0x1c, 0x40, 0x75, 0xbf, 0x7d, 0xd8, 0x23, 0xee, 0xe0, 0x97, 0x15, 0x28, 0xf4, 0xd8, 0x52];

    #[cfg(feature = "x128_256")] let key =
            [0x11, 0x00, 0x33, 0x22, 0x55, 0x44, 0x77, 0x66, 0x99, 0x88, 0xbb, 0xaa, 0xdd, 0xcc, 0xff, 0xee,
            0xee, 0xff, 0xcc, 0xdd, 0xaa, 0xbb, 0x88, 0x99, 0x66, 0x77, 0x44, 0x55, 0x22, 0x33, 0x00, 0x11];
    #[cfg(feature = "x128_256")] let plaintext = [0x23, 0x01, 0x67, 0x45, 0xab, 0x89, 0xef, 0xcd, 0xdc, 0xfe, 0x98, 0xba, 0x54, 0x76, 0x10, 0x32];
    #[cfg(feature = "x128_256")] let ciphertext = [0x28, 0x33, 0x37, 0xe6, 0xc7, 0x14, 0xe6, 0x6c, 0xd1, 0x32, 0x54, 0x5a, 0xb0, 0xe4, 0x20, 0xc8];

    let mut block = plaintext;
    let cipher = Sparx::new(&key);
    cipher.encrypt(&mut block);
    assert_eq!(ciphertext, block);
    cipher.decrypt(&mut block);
    assert_eq!(plaintext, block);
}
